## 题意简述
- 在 $b$ 进制下，取一正整数 $n$，在保留 $k$ 个有效数字时计算 $1 \div n = n'$，再计算 $1 \div n' = n''$，求有多少 $n$ 满足 $n = n''$。
- 答案对 $998,244,353$ 取模。
- 有多组数据。

## 解题思路
首先明确，对于一个正整数 $n$，$n$ 与 $n''$ 是否相等只与第一次计算是否准确有关。因为如果第一次计算准确，则有 $n' = \frac{1}{n}$。那么 $n'' = 1 \div n' = n$。

那么，如何判断第一次计算是否准确呢？

我们回顾一下进制的知识：

在 $k$ 进制下，如果小数点后的第 $t$ 位上位 $c$，则实际代表的数字大小为 $\frac{c}{t^n}$。

原题中，给定 $n$，需要计算的是 $\frac{1}{n}$，那么问题就转化成了：

构造一个非负整数数列 $a_1,a_2,...,a_k$，使其满足 $\sum_{i=1}^{k-1}\frac{a_i}{b^i} = \frac{1}{n}$，求共有多少种方案。

我们先来考虑小数后只有一位的情况。

给出结论：方案数等于 $b$ 的因子个数。

尝试证明：

若 $\frac{1}{n}$ 可以表示出来，则存在 $p$ 使 $\frac{p}{b} = \frac{1}{n}$，而当且仅当 $p$ 为 $b$ 的因子时，$\frac{p}{b}$ 约分后分子为 $1$。

那么如果小数后有多位呢？其实这个问题很容易转化：若 $b$ 进制下小数后有 $k$ 位，则其方案数恰好等于 $b^k$ 进制下小数后有 $1$ 位的方案数。（想一想，为什么？）

到这里，这个问题就解决了。

## 代码实现
- 注意小数点前面整数部分还有一位。
- 代码很丑，轻喷。QwQ

```cpp
#include<bits/stdc++.h>
#define mod 998244353
int a[100005];
int main(void){
    int t;
    scanf("%d",&t);
    while(t--){
        int b,k;
        scanf("%d%d",&b,&k);
        memset(a,0,sizeof(a));
        int i = 2;
        while(b > 1){
            if(b % i)
                ++ i;
            else
                ++ a[i],b /= i;
        }
        long long int sum = 1;
        for(int j = 2;j <= i;++ j)
        	if(a[j])
            	sum = sum * ((1ll * a[j] * (k-1) + 1) % mod) % mod;
        printf("%lld\n",sum);
    }
    return 0;
}

```